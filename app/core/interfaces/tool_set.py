"""
ToolSet interfaces for the SmartNinja application.
These interfaces define a unified access point for all external tools.
"""
import asyncio
import logging
from abc import ABC, abstractmethod
from datetime import datetime
from typing import Any, Dict, List, Optional

from app.mcp.analyze_prices import analyze_prices_service
from app.mcp.track_price_history import track_price_history_service


class ISmartNinjaToolSet(ABC):
    """
    Interface for a unified toolset that provides access to all external tools.
    Serves as a facade for various services like scrapers, formatters, and LLM clients.
    """

    @abstractmethod
    async def scrape_prices(self, model: str, country: str) -> List[Dict[str, Any]]:
        """
        Asynchronously scrape prices for a specific model and country.

        Args:
            model: The phone model to search for (e.g., "iPhone 15")
            country: The country to search prices in (e.g., "US", "BR")

        Returns:
            List of dictionaries containing phone offers with price information

        Raises:
            ValueError: If model or country parameters are invalid
            RuntimeError: If scraping fails
        """

    @abstractmethod
    async def normalize_data(self, price_data: List[Dict[str, Any]]) -> str:
        """
        Asynchronously normalize and format raw price data into a standardized format.

        Args:
            price_data: List of price data dictionaries

        Returns:
            Formatted string representation of the price data
        """

    @abstractmethod
    async def generate_prompt(self, formatted_data: str) -> str:
        """
        Asynchronously generate a prompt for analysis based on formatted data.

        Args:
            formatted_data: Formatted price data string

        Returns:
            Prompt text for LLM analysis
        """

    @abstractmethod
    async def get_ai_analysis(self, prompt: str) -> Optional[str]:
        """
        Asynchronously get AI-generated analysis from a prompt.

        Args:
            prompt: The prompt to send to the LLM

        Returns:
            Analysis text generated by the LLM, or None if generation fails
        """

    @abstractmethod
    async def get_rule_analysis(self, price_data: List[Dict[str, Any]]) -> str:
        """
        Asynchronously get rule-based analysis for price data.

        Args:
            price_data: List of price data dictionaries

        Returns:
            Analysis text generated from rules
        """

    @abstractmethod
    async def process_price_analysis(self, model: str, country: str) -> Optional[str]:
        """
        Asynchronously process the complete price analysis workflow from scraping to analysis.

        Args:
            model: The phone model to search for (e.g., "iPhone 15")
            country: The country to search prices in (e.g., "US", "BR")

        Returns:
            Final analysis result or None if any step fails
        """

    @abstractmethod
    async def format_output(self, data: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """
        Asynchronously format output data for presentation.

        Args:
            data: Dictionary with output data to format

        Returns:
            Formatted output data or None if formatting fails
        """


from app.core.analyzer.interfaces import (
    LLMClient,
    PriceFormatter,
    PromptGenerator,
    RuleBasedAnalyzer,
)

# This will be implemented after the interface is tested
from app.core.interfaces.scraping import IPriceAnalyzer, IScraperService


class SmartNinjaToolSet(ISmartNinjaToolSet):
    """
    Implementation of the SmartNinjaToolSet interface.
    Provides unified access to all tools in the system.
    """

    def __init__(
        self,
        scraper_service: IScraperService,
        price_formatter: PriceFormatter,
        prompt_generator: PromptGenerator,
        llm_client: LLMClient,
        rule_based_analyzer: RuleBasedAnalyzer,
    ):
        """
        Initialize the ToolSet with all required components.

        Args:
            scraper_service: Service for scraping price data
            price_formatter: Service for formatting price data
            prompt_generator: Service for generating prompts
            llm_client: Client for communicating with LLMs
            rule_based_analyzer: Service for rule-based analysis
        """
        self.scraper_service = scraper_service
        self.price_formatter = price_formatter
        self.prompt_generator = prompt_generator
        self.llm_client = llm_client
        self.rule_based_analyzer = rule_based_analyzer

    async def scrape_prices(self, model: str, country: str) -> List[Dict[str, Any]]:
        """
        Asynchronously scrape prices for a specific model and country.

        Args:
            model: The phone model to search for
            country: The country to search prices in

        Returns:
            List of dictionaries containing phone offers with price information
        """
        return await self.scraper_service.get_prices(model, country)

    async def normalize_data(self, price_data: List[Dict[str, Any]]) -> str:
        """
        Asynchronously normalize and format raw price data into a standardized format.

        Args:
            price_data: List of price data dictionaries

        Returns:
            Formatted string representation of the price data
        """
        # Use a thread pool executor for CPU-bound operations
        import concurrent.futures
        
        loop = asyncio.get_event_loop()
        with concurrent.futures.ThreadPoolExecutor() as pool:
            # Run CPU-bound operation in a separate thread to avoid blocking
            return await loop.run_in_executor(
                pool, self.price_formatter.format_price_data, price_data
            )

    async def generate_prompt(self, formatted_data: str) -> str:
        """
        Asynchronously generate a prompt for analysis based on formatted data.

        Args:
            formatted_data: Formatted price data string

        Returns:
            Prompt text for LLM analysis
        """
        # Use a thread pool executor for CPU-bound operations
        import concurrent.futures
        
        loop = asyncio.get_event_loop()
        with concurrent.futures.ThreadPoolExecutor() as pool:
            # Run CPU-bound operation in a separate thread to avoid blocking
            return await loop.run_in_executor(
                pool, self.prompt_generator.generate_prompt, formatted_data
            )

    async def get_ai_analysis(self, prompt: str) -> Optional[str]:
        """
        Asynchronously get AI-generated analysis from a prompt.

        Args:
            prompt: The prompt to send to the LLM

        Returns:
            Analysis text generated by the LLM, or None if generation fails
        """
        try:
            # Create sample price data for the analysis (this would normally come from scrape_prices)
            # In a production environment, this would use real data from previous steps
            sample_data = [
                {"model": "iPhone 15", "price": 999.99, "currency": "USD", "store": "Apple Store"},
                {"model": "iPhone 15", "price": 949.99, "currency": "USD", "store": "BestBuy"}
            ]
            
            # Call the MCP analyze_prices_service directly
            params = {
                "prices": sample_data,
                "include_justification": True
            }
            
            result = await analyze_prices_service(params)
            
            if result.get("status") != "success":
                logging.error(f"Analysis service error: {result.get('message')}")
                return None
                
            # Extract the analysis from the result
            analysis_data = result.get("data", {})
            analysis_text = analysis_data.get("analysis", "")
            
            return analysis_text
        except Exception as e:
            logging.error(f"Error generating AI analysis: {e}")
            return None

    async def get_rule_analysis(self, price_data: List[Dict[str, Any]]) -> str:
        """
        Asynchronously get rule-based analysis for price data.

        Args:
            price_data: List of price data dictionaries

        Returns:
            Analysis text generated from rules
        """
        # Assume rule_based_analyzer.analyze is still synchronous (CPU-bound)
        # but we keep the method async for interface consistency
        return self.rule_based_analyzer.analyze(price_data)

    async def process_price_analysis(self, model: str, country: str) -> Optional[str]:
        """
        Asynchronously process the complete price analysis workflow from scraping to analysis.

        Args:
            model: The phone model to search for
            country: The country to search prices in

        Returns:
            Final analysis result or None if any step fails
        """
        try:
            # Step 1: Scrape prices
            price_data = await self.scrape_prices(model, country)
            
            if not price_data:
                logging.warning(f"No price data found for {model} in {country}")
                return "No price data available for analysis."
            
            # Step 2: Call the analyze_prices_service directly
            params = {
                "prices": price_data,
                "include_justification": True
            }
            
            result = await analyze_prices_service(params)
            
            if result.get("status") != "success":
                logging.error(f"Analysis service error: {result.get('message')}")
                # Fallback to rule-based analysis
                logging.warning("MCP analysis failed, falling back to rule-based")
                return await self.get_rule_analysis(price_data)
                
            # Extract the analysis from the result
            analysis_data = result.get("data", {})
            analysis_text = analysis_data.get("analysis", "")
            
            if analysis_text:
                return analysis_text
            else:
                # Fallback to rule-based analysis
                logging.warning("MCP analysis returned empty result, falling back to rule-based")
                return await self.get_rule_analysis(price_data)
        except Exception as e:
            logging.error(f"Error in process_price_analysis: {e}")
            # Attempt to use rule-based as last resort
            try:
                return await self.get_rule_analysis(price_data)
            except:
                return None

    async def format_output(self, data: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """
        Asynchronously format output data for presentation.

        Args:
            data: Dictionary with output data to format

        Returns:
            Formatted output data or None if formatting fails
        """
        try:
            # Basic formatting logic, could be expanded
            # This is CPU-bound, but kept as async for interface consistency
            return {
                "status": "success",
                "data": data,
                "formatted_at": datetime.now().isoformat(),
            }
        except Exception as e:
            logging.error(f"Error formatting output: {e}")
            return None
